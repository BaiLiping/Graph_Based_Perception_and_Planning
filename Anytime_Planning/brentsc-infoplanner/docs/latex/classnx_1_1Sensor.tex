\hypertarget{classnx_1_1Sensor}{}\section{nx\+:\+:Sensor$<$ state $>$ Class Template Reference}
\label{classnx_1_1Sensor}\index{nx\+::\+Sensor$<$ state $>$@{nx\+::\+Sensor$<$ state $>$}}


{\ttfamily \#include $<$sensor.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnx_1_1Sensor_a7f5218bff3e514d6539caabdbbb5e077}\label{classnx_1_1Sensor_a7f5218bff3e514d6539caabdbbb5e077}} 
{\bfseries Sensor} (int z\+\_\+dim)
\item 
virtual Vector\+Xd \hyperlink{classnx_1_1Sensor_a1dfc0088b798aa167c666f7e00587ab3}{Sense} (const state \&x, const Vector\+Xd \&target)=0
\item 
virtual std\+::vector$<$ \hyperlink{structnx_1_1Measurement}{Measurement} $>$ \hyperlink{classnx_1_1Sensor_a6c8d5300337277858d417f6279f851a7}{Sense\+Multiple} (const state \&x, const std\+::shared\+\_\+ptr$<$ \hyperlink{classnx_1_1TargetModel}{Target\+Model} $>$ \&tmm)=0
\item 
virtual void \hyperlink{classnx_1_1Sensor_aa9b370055e91f8913915d12d18450743}{Get\+Jacobian} (Matrix\+Xd \&H, Matrix\+Xd \&V, const state \&x, const std\+::shared\+\_\+ptr$<$ \hyperlink{classnx_1_1InfoTargetModel}{Info\+Target\+Model} $>$ \&tmm) const =0
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnx_1_1Sensor_ac6a5a70ce332694a2c7a6b5aa1dcaf1d}\label{classnx_1_1Sensor_ac6a5a70ce332694a2c7a6b5aa1dcaf1d}} 
int {\bfseries z\+\_\+dim}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class state$>$\newline
class nx\+::\+Sensor$<$ state $>$}

Generic interface for an abstract sensor type. Supports generating single measurements of a target from a state, a vector of measurements of multiple targets from a \hyperlink{classnx_1_1TargetModel}{Target\+Model}, and computation of Jacobian matrices. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classnx_1_1Sensor_aa9b370055e91f8913915d12d18450743}\label{classnx_1_1Sensor_aa9b370055e91f8913915d12d18450743}} 
\index{nx\+::\+Sensor@{nx\+::\+Sensor}!Get\+Jacobian@{Get\+Jacobian}}
\index{Get\+Jacobian@{Get\+Jacobian}!nx\+::\+Sensor@{nx\+::\+Sensor}}
\subsubsection{\texorpdfstring{Get\+Jacobian()}{GetJacobian()}}
{\footnotesize\ttfamily template$<$class state $>$ \\
virtual void \hyperlink{classnx_1_1Sensor}{nx\+::\+Sensor}$<$ state $>$\+::Get\+Jacobian (\begin{DoxyParamCaption}\item[{Matrix\+Xd \&}]{H,  }\item[{Matrix\+Xd \&}]{V,  }\item[{const state \&}]{x,  }\item[{const std\+::shared\+\_\+ptr$<$ \hyperlink{classnx_1_1InfoTargetModel}{Info\+Target\+Model} $>$ \&}]{tmm }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

Computes the Jacobian of the sensor measurement model. 
\begin{DoxyParams}{Parameters}
{\em H} & The Jacobian of the measurement model. \\
\hline
{\em V} & The covariance matrix. \\
\hline
{\em x} & The robot state to compute the Jacobian with respect to. \\
\hline
{\em y} & The target state to compute the Jacobian with respect to. \\
\hline
{\em y\+\_\+dim} & The dimensionality of the target, needed for correct matrix sizing. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classnx_1_1Sensor_a1dfc0088b798aa167c666f7e00587ab3}\label{classnx_1_1Sensor_a1dfc0088b798aa167c666f7e00587ab3}} 
\index{nx\+::\+Sensor@{nx\+::\+Sensor}!Sense@{Sense}}
\index{Sense@{Sense}!nx\+::\+Sensor@{nx\+::\+Sensor}}
\subsubsection{\texorpdfstring{Sense()}{Sense()}}
{\footnotesize\ttfamily template$<$class state $>$ \\
virtual Vector\+Xd \hyperlink{classnx_1_1Sensor}{nx\+::\+Sensor}$<$ state $>$\+::Sense (\begin{DoxyParamCaption}\item[{const state \&}]{x,  }\item[{const Vector\+Xd \&}]{target }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Computes a single measurement vector of the target from a state x. 
\begin{DoxyParams}{Parameters}
{\em x} & The state sensing from. \\
\hline
{\em target} & The target being sensed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The resulting measurement. 
\end{DoxyReturn}
\mbox{\Hypertarget{classnx_1_1Sensor_a6c8d5300337277858d417f6279f851a7}\label{classnx_1_1Sensor_a6c8d5300337277858d417f6279f851a7}} 
\index{nx\+::\+Sensor@{nx\+::\+Sensor}!Sense\+Multiple@{Sense\+Multiple}}
\index{Sense\+Multiple@{Sense\+Multiple}!nx\+::\+Sensor@{nx\+::\+Sensor}}
\subsubsection{\texorpdfstring{Sense\+Multiple()}{SenseMultiple()}}
{\footnotesize\ttfamily template$<$class state $>$ \\
virtual std\+::vector$<$\hyperlink{structnx_1_1Measurement}{Measurement}$>$ \hyperlink{classnx_1_1Sensor}{nx\+::\+Sensor}$<$ state $>$\+::Sense\+Multiple (\begin{DoxyParamCaption}\item[{const state \&}]{x,  }\item[{const std\+::shared\+\_\+ptr$<$ \hyperlink{classnx_1_1TargetModel}{Target\+Model} $>$ \&}]{tmm }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

The sense function returns a vector of sensor measurements from the environment. 
\begin{DoxyParams}{Parameters}
{\em x} & The state to generate measurements from. \\
\hline
{\em tmm} & The \hyperlink{structnx_1_1Target}{Target} Model. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The vector of sensor measurements generated. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/igl/sensing/sensor.\+h\end{DoxyCompactItemize}
